package {{package-name}};

// import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import fi.tnie.db.ent.EnumMetaData;
import fi.tnie.db.ent.EntityFactory;
// import fi.tnie.db.ent.value.IntegerKey;
// import fi.tnie.db.ent.value.IntegerValue;
import fi.tnie.db.ent.value.Key;
// import fi.tnie.db.ent.value.VarcharKey;
// import fi.tnie.db.ent.value.VarcharValue;
import fi.tnie.db.meta.Column;
import fi.tnie.db.meta.BaseTable;
import fi.tnie.db.meta.ForeignKey;
{{imports}}


/**
	Generated by fi.tnie.db.source.SourceGenerator
*/
public class {{table-impl-class}}
    extends {{table-impl-base}} {
        
    private {{table-interface}}.Holder holder;
    
    /**
     * generated value variable list below: 
     */
    {{value-variable-list}}
    
    public static class {{table-interface}}MetaData
        extends EnumMetaData
    <
        {{table-interface}}.Attribute, 
        {{table-interface}}.Reference,
        {{table-interface}}.Type,
        {{table-interface}}> {

        private static final {{table-interface}}MetaData instance = new {{table-interface}}MetaData();
        private static final Factory factory = new Factory();
        
        {{attribute-key-map-list}}
                
        private Map<Column, Key<Attribute, ?, ?, ?, {{table-interface}}, ?>> columnKeyMap;        
        private Map<Attribute, Key<Attribute, ?, ?, ?, {{table-interface}}, ?>> attributeKeyMap = new HashMap<Attribute, Key<Attribute, ?, ?, ?, {{table-interface}}, ?>>();
                
        // {{column-key-map}}
        // {{attribute-key-map}}
    
        public {{table-interface}}MetaData() {
            super({{table-interface}}.Attribute.class, {{table-interface}}.Reference.class);
            {{meta-data-initialization}}
        }
        
        @Override
        public Factory getFactory() {
			return factory;       
        }
        
        public static {{table-interface}}MetaData getInstance() {
        	return {{table-interface}}MetaData.instance; 
        }
        
        @Override
	    public Type getType() {
	     	return {{table-interface}}.TYPE;
	    }   
	    
	    @Override
		protected Column map(BaseTable table, Attribute a) {		
			return table.columnMap().get(a.identifier());
		}

		@Override
		protected ForeignKey map(BaseTable table, Reference r) {
			return table.foreignKeys().get(r.identifier());			
		}
		
		/**
			If there are no two (or more) attributes with equals type, we don't need this.  
		*/		
		@SuppressWarnings("unused")
		private 
		<K extends Key<Attribute, ?, ?, ?, {{table-interface}}, ?>>
		void addAttributeKey(K key, Map<Attribute, K> am) {
			Attribute n = key.name();
			am.put(n, key);
			attributeKeyMap.put(n, key);
		}
		
		@Override
		public Key<Attribute, ?, ?, ?, {{table-interface}}, ?> getKey(Column column) {
			if (column == null) {
				throw new NullPointerException("column");
			}
			
			return getColumnKeyMap().get(column);
		}
		
		@Override
		public Key<Attribute, ?, ?, ?, {{table-interface}}, ?> getKey(Attribute attribute) {
			if (attribute == null) {
				throw new NullPointerException("attribute");
			}
		
			return attributeKeyMap.get(attribute);
		}
		
		private void add(Key<Attribute, ?, ?, ?, {{table-interface}}, ?> key, Map<Column, Key<Attribute,?,?,?,{{table-interface}},?>> cm) {
			cm.put(getColumn(key.name()), key);
		}		
		
		private Map<Column, Key<Attribute, ?, ?, ?, {{table-interface}}, ?>> getColumnKeyMap() {
			if (columnKeyMap == null) {
				columnKeyMap = new HashMap<Column, Key<Attribute,?,?,?,{{table-interface}},?>>();
				// add(PersonMetaData.ID, columnKeyMap);
				{{column-key-map-population}}				
			}

			return columnKeyMap;
		}
		
		
		/**
		    something like that for all primitive types: 
		 
			@Override
			public IntegerKey<Attribute, Person> getIntegerKey(Attribute attribute) {
				if (attribute == null) {
					throw new NullPointerException("attribute");
				}
				
				return integerKeyMap.get(attribute);
			}		  
		 */
				
		 {{key-accessor-list}}
		 
		 
    }    
        
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;    
    
    public {{table-impl-class}}() {
    }

    @Override       
    public {{table-interface}}MetaData getMetaData() {      
        return {{table-interface}}MetaData.instance;
    }
    
    public static class Factory
    	implements EntityFactory<{{table-interface}}.Attribute, {{table-interface}}.Reference, {{table-interface}}.Type, {{table-interface}}> {
        @Override
        public {{table-impl-base}} newInstance() {
           return new {{table-impl-class}}();
        }       
    }
    
    @Override       
    public {{table-impl-base}} self() {     
        return this;
    }
    
    @Override
	public {{table-interface}}.Holder ref() {
		if (holder == null) {
			holder = new {{table-interface}}.Holder(this);		
		}

		return holder;		
	}
	
	
	/**	
    	public VarcharValue<Attribute, Person> lastName() {
	    	if (this.lastName == null) {
	    		this.lastName = varcharValue(PersonMetaData.LAST_NAME);
	    	}
	    	
	    	return this.lastName;
	    }	
	*/
	
	
	{{value-accessor-list}}
    
        
    {{accessor-list}}
} 

