/*
 * Copyright (c) 2009-2013 Topi Nieminen
 */
package fi.tnie.db;

import java.sql.Connection;
import java.util.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.EnumMap;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;

import fi.tnie.db.expr.Assignment;
import fi.tnie.db.expr.ColumnName;
import fi.tnie.db.expr.ElementList;
import fi.tnie.db.expr.ElementVisitor;
import fi.tnie.db.expr.InsertQuery;
import fi.tnie.db.expr.Parameter;
import fi.tnie.db.expr.TableColumnExpr;
import fi.tnie.db.expr.TableReference;
import fi.tnie.db.expr.UpdateQuery;
import fi.tnie.db.expr.ValueParameter;
import fi.tnie.db.expr.Predicate;
import fi.tnie.db.expr.TableColumnName;
import fi.tnie.db.expr.ValueExpression;
import fi.tnie.db.expr.ValueRow;
import fi.tnie.db.expr.VisitContext;
import fi.tnie.db.expr.op.AndPredicate;
import fi.tnie.db.expr.op.Comparison;
import fi.tnie.db.meta.BaseTable;
import fi.tnie.db.meta.Column;
import fi.tnie.db.meta.PrimaryKey;

public abstract class Entity<K extends Enum<K>, E extends Entity<K, E>> 
	extends DBObject<K> {

	private Date deleted;
	private Map<K, ?> loadedAs = null;
		
	private EnumMap<K, Parameter> parameterMap;
			
	public abstract EntityFactory<K, E> getFactory();
	
	private static Logger logger = Logger.getLogger(Entity.class);

	@Override
	protected Map<K, Object> createValueMap() {				
		return new EnumMap<K, Object>(getFactory().getColumnNameType());
	}

	void markDeleted() {
		this.deleted = new Date();
	}

	void save(Connection c)
		throws SQLException {
								
		saving();
						
		if (isNew()) {
//			getFactory();			
			insert(c);
		}
		else {
			update(c);
		}
		
//		if (())) {
////			if (!isDeleted()) {
////				
////			}			
//		}
//		else {
//			
//		}
		
//		st.executeUpdate(sql, autoGeneratedKeys)		
						
		saved();
	}
	
	private void insert(Connection c) 
		throws SQLException {		
		 
		ValueRow newRow = new ValueRow();
		BaseTable t = getFactory().getTable();
		Map<String, Column> cm = t.columns();		
		ElementList<ColumnName> names = new ElementList<ColumnName>(); 
				
		for (Map.Entry<K, ?> e : values().entrySet()) {			
			K k = e.getKey();			
			Column col = cm.get(k.toString());
			names.add(new TableColumnName(col));
			ValueParameter p = new ValueParameter(col, e.getValue());
			newRow.add(p);
		}
				
		InsertQuery q = new InsertQuery(t, names, newRow);				
		String qs = q.generate();
		
		final PreparedStatement ps = c.prepareStatement(qs, Statement.RETURN_GENERATED_KEYS);
						
		q.traverse(null, new ParameterAssignment(ps));
				
		int ins = ps.executeUpdate();
		
		logger().debug("inserted: " + ins);
		
		ResultSet rs = ps.getGeneratedKeys();
		
		try {
			EntityFactory<K, E> ef = getFactory();			
			EnumMap<K, Integer> keys = ef.keys(rs.getMetaData());					
			
			if (rs.next()) {
				ef.copy(keys, rs, this);				
			}
		}
		finally {
			rs.close();
		}
	}
	
	
	private void update(Connection c) 
		throws SQLException {

		EntityFactory<K, E> ef = getFactory();
		
		BaseTable t = ef.getTable();
		Map<String, Column> cm = t.columns();		
		ElementList<Assignment> assignments = new ElementList<Assignment>(); 
				
		for (Map.Entry<K, ?> e : values().entrySet()) {			
			K k = e.getKey();			
			Column col = getFactory().getColumn(k);
			ValueParameter p = new ValueParameter(col, e.getValue());
			assignments.add(new Assignment(new TableColumnName(col), p));						
		}
				
		// reload:
		E snapshot = ef.reload(this, c);
		
		if (snapshot == null) {
			// TODO: return diff: 
			throw new IllegalStateException("object was deleted");
		}
						
		UpdateQuery q = new UpdateQuery(t, assignments);				
		String qs = q.generate();
		
		final PreparedStatement ps = c.prepareStatement(qs, Statement.RETURN_GENERATED_KEYS);						
		q.traverse(null, new ParameterAssignment(ps));				
		int ins = ps.executeUpdate();
		
		logger().debug("updated: " + ins);
		
		ResultSet rs = ps.getGeneratedKeys();
		
		try {						
			EnumMap<K, Integer> keys = ef.keys(rs.getMetaData());					
			
			if (rs.next()) {
				ef.copy(keys, rs, this);				
			}
		}
		finally {
			rs.close();
		}
	}
	
	public boolean isNew() {
		return (this.loadedAs == null); 
	}
			
	
	protected Map<K, ?> getPrimaryKey() {		
		Map<K, ?> vm = values();
		Class<K> kt = getFactory().getColumnNameType();
		EnumMap<K, Object> pk = new EnumMap<K, Object>(kt);
		Set<K> keys = getFactory().getPKDefinition();
		
		for (K k : keys) {
			Object value = vm.get(k);
			
			if (value == null) {
				return null;			
			}
			
			pk.put(k, value);
		}
				
		return pk;
	}		
	
	/**
	 * Returns true, if and only if every component of the primary key
	 * is either set or known to be in auto-increment column.
	 * 
	 * @return
	 */
	
	protected boolean isInsertable() {
		PrimaryKey pk = getPKDefinition();		
		Map<K, Object> vm = values();
		
		for (Column c : pk.columns()) {
			Boolean ai = c.isAutoIncrement();		
						
			if (ai != null && ai.booleanValue() == false) {				
				K key = getKey(c.getName());				
				Object value = vm.get(key);
				
				if (value == null) {
					return false;
				}
			}
		}		
		
		return true;
	}
	
	public K getKey(String n)  {
		Class<K> kt = getFactory().getColumnNameType();				
		return Enum.valueOf(kt, n);
	}
	

	protected void saved() {
		// TODO Auto-generated method stub		
	}

	protected void saving() {		
	}		
	
	private PrimaryKey getPKDefinition() {
		BaseTable t = getFactory().getTable();
		
		if (t == null) {
			throw new IllegalStateException("No base table for the entity: " + this);			
		}
		
		PrimaryKey pk = t.getPrimaryKey();
		
		if (pk == null) {
			throw new IllegalStateException("No primary key in table: " + t.getQualifiedName());
		}		
		
		return pk;
	}
	
	public void markLoaded() {		
		this.loadedAs = new EnumMap<K, Object>(values());		 		
	}
	
	public Predicate eq(K k, ValueExpression expr) {				
		return Comparison.eq(getParameter(k), expr);
	}
		
	public Predicate loadedAs(EntityQuery<K, E> q) {
		Predicate p = null;		
		
		EntityFactory<K, E> ef = getFactory();
		TableReference tref = q.getTableReference();
				
		for (K k : ef.getPKDefinition()) {
			Column c = ef.getColumn(k);
			Object v = loadedAs.get(k);			
						
			p = AndPredicate.newAnd(p, Comparison.eq(
					new TableColumnExpr(tref, c), new ValueParameter(c, v)));
		}
		
		return p;
	}
	
	
	
	
	/**
	 * Returns a parameter view to the <code>key</code> value of this entity.
	 * Further changes to this value are visible via the returned parameter object.
	 * 
	 * @param key
	 * @return
	 */
	
	public Parameter getParameter(final K key) {
		if (key == null) {
			throw new NullPointerException("'key' must not be null");
		}
		
		EnumMap<K, Parameter> pm = getParameterMap();
		Parameter p = pm.get(key);
		
		if (p == null) {
			Column c = getFactory().getColumn(key);			
			
			p = new Parameter(c) {
				@Override
				public Object getValue() {					
					return values().get(key);
				}

				@Override
				public void traverse(VisitContext vc, ElementVisitor v) {
					v.start(vc, this);
					v.end(this);
				}
			};
		}
		
		return p;
	}
	
	
	
	private EnumMap<K, Parameter> getParameterMap() {
		if (parameterMap == null) {
			parameterMap = new EnumMap<K, Parameter>(getFactory().getColumnNameType());			
		}

		return parameterMap;
	}
		
	private static Logger logger() {
		return Entity.logger;
	}
	
	
	public void diff(E another) {
		
		
	}				
	
}
 