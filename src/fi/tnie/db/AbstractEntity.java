/*
 * Copyright (c) 2009-2013 Topi Nieminen
 */
package fi.tnie.db;


public abstract class AbstractEntity<
	A extends Enum<A> & Identifiable, 
	R extends Enum<R> & Identifiable,
	Q extends Enum<Q> & Identifiable,
	E extends AbstractEntity<A, R, Q, E>
> 
	implements Entity<A, R>
{	
	 
	
	
	
//	private Date deleted;
//	
//	private Map<A, ?> loadedAs = null;		
//	private EnumMap<A, Parameter> parameterMap;
//			
////	public abstract EntityFactory<A, E> getFactory();
//	
//	private static Logger logger = Logger.getLogger(AbstractEntity.class);
//	
////	protected Map<A, Object> createValueMap() {				
////		return new EnumMap<A, Object>(getFactory().getColumnNameType());
////	}
//		
//	
//
//	void markDeleted() {
//		this.deleted = new Date();
//	}
//
//	void save(Connection c)
//		throws SQLException {
//								
//		saving();
//						
//		if (isNew()) {
////			getFactory();			
//			insert(c);
//		}
//		else {
//			update(c);
//		}
//		
////		if (())) {
//////			if (!isDeleted()) {
//////				
//////			}			
////		}
////		else {
////			
////		}
//		
////		st.executeUpdate(sql, autoGeneratedKeys)		
//						
//		saved();
//	}
//	
//	private void insert(Connection c) 
//		throws SQLException {		
//		 
////		ValueRow newRow = new ValueRow();
////		BaseTable t = getFactory().getTable();
////		Map<String, Column> cm = t.columns();		
////		ElementList<ColumnName> names = new ElementList<ColumnName>(); 
////				
////		for (Map.Entry<A, ?> e : values().entrySet()) {			
////			A k = e.getKey();			
////			Column col = cm.get(k.toString());
////			names.add(new TableColumnName(col));
////			ValueParameter p = new ValueParameter(col, e.getValue());
////			newRow.add(p);
////		}
////				
////		InsertStatement q = new InsertStatement(t, names, newRow);				
////		String qs = q.generate();
////		
////		final PreparedStatement ps = c.prepareStatement(qs, Statement.RETURN_GENERATED_KEYS);
////						
////		q.traverse(null, new ParameterAssignment(ps));
////				
////		int ins = ps.executeUpdate();
////		
////		logger().debug("inserted: " + ins);
////		
////		ResultSet rs = ps.getGeneratedKeys();
////		
////		try {
////			EntityFactory<A, E> ef = getFactory();			
////			EnumMap<A, Integer> keys = ef.keys(rs.getMetaData());					
////			
////			if (rs.next()) {
////				ef.copy(keys, rs, this);				
////			}
////		}
////		finally {
////			rs.close();
////		}
//	}
//	
//	
//	private void update(Connection c) 
//		throws SQLException {
//
////		EntityFactory<A, E> ef = getFactory();
////		
////		BaseTable t = ef.getTable();
////		Map<String, Column> cm = t.columns();		
////		ElementList<Assignment> assignments = new ElementList<Assignment>(); 
////				
////		for (Map.Entry<A, ?> e : values().entrySet()) {			
////			A k = e.getKey();			
////			Column col = getFactory().getColumn(k);
////			ValueParameter p = new ValueParameter(col, e.getValue());
////			assignments.add(new Assignment(new TableColumnName(col), p));						
////		}
////				
////		// reload:
////		E snapshot = ef.reload(this, c);
////		
////		if (snapshot == null) {
////			// TODO: return diff: 
////			throw new IllegalStateException("object was deleted");
////		}
////						
////		UpdateStatement q = new UpdateStatement(t, assignments);				
////		String qs = q.generate();
////		
////		final PreparedStatement ps = c.prepareStatement(qs, Statement.RETURN_GENERATED_KEYS);						
////		q.traverse(null, new ParameterAssignment(ps));				
////		int ins = ps.executeUpdate();
////		
////		logger().debug("updated: " + ins);
////		
////		ResultSet rs = ps.getGeneratedKeys();
////		
////		try {						
////			EnumMap<A, Integer> keys = ef.keys(rs.getMetaData());					
////			
////			if (rs.next()) {
////				ef.copy(keys, rs, this);				
////			}
////		}
////		finally {
////			rs.close();
////		}
//	}
//	
//	public boolean isNew() {
//		return (this.loadedAs == null); 
//	}
//			
//	
//	protected Map<A, ?> getPrimaryKey() {		
//		Map<A, ?> vm = values();
//		Class<A> kt = getFactory().getColumnNameType();
//		EnumMap<A, Object> pk = new EnumMap<A, Object>(kt);
//		Set<A> keys = getFactory().getPKDefinition();
//		
//		for (A k : keys) {
//			Object value = vm.get(k);
//			
//			if (value == null) {
//				return null;			
//			}
//			
//			pk.put(k, value);
//		}
//				
//		return pk;
//	}		
//	
//	private Map<A, ?> values() {
//		// TODO Auto-generated method stub
//		return null;
//	}
//
//
//	/**
//	 * Returns true, if and only if every component of the primary key
//	 * is either set or known to be in auto-increment column.
//	 * 
//	 * @return
//	 */
//	
//	protected boolean isInsertable() {
//		PrimaryKey pk = getPKDefinition();		
//		Map<A, ?> vm = values();
//		
//		for (Column c : pk.columns()) {
//			Boolean ai = c.isAutoIncrement();		
//						
//			if (ai != null && ai.booleanValue() == false) {				
//				A key = getKey(c.getColumnName().getName());				
//				Object value = vm.get(key);
//				
//				if (value == null) {
//					return false;
//				}
//			}
//		}		
//		
//		return true;
//	}
//	
//	public A getKey(String n)  {
//		Class<A> kt = getFactory().getColumnNameType();				
//		return Enum.valueOf(kt, n);
//	}
//	
//
//	protected void saved() {
//		// TODO Auto-generated method stub		
//	}
//
//	protected void saving() {		
//	}		
//	
//	private PrimaryKey getPKDefinition() {
//		BaseTable t = getFactory().getTable();
//		
//		if (t == null) {
//			throw new IllegalStateException("No base table for the entity: " + this);			
//		}
//		
//		PrimaryKey pk = t.getPrimaryKey();
//		
//		if (pk == null) {
//			throw new IllegalStateException("No primary key in table: " + t.getQualifiedName());
//		}		
//		
//		return pk;
//	}
//	
//	public void markLoaded() {		
//		this.loadedAs = new EnumMap<A, Object>(values());		 		
//	}
//	
//	public Predicate eq(A k, ValueExpression expr) {				
//		return Comparison.eq(getParameter(k), expr);
//	}
//		
//	public Predicate loadedAs(EntityQuery<A, E> q) {
//		Predicate p = null;		
//		
//		EntityFactory<A, E> ef = getFactory();
//		TableReference tref = q.getTableReference();
//				
//		for (A k : ef.getPKDefinition()) {
//			Column c = ef.getColumn(k);
//			Object v = loadedAs.get(k);			
//						
//			p = AndPredicate.newAnd(p, Comparison.eq(
//					new TableColumnExpr(tref, c), new ValueParameter(c, v)));
//		}
//		
//		return p;
//	}
//	
//	
//	
//	
//	/**
//	 * Returns a parameter view to the <code>key</code> value of this entity.
//	 * Further changes to this value are visible via the returned parameter object.
//	 * 
//	 * @param key
//	 * @return
//	 */
//	
//	public Parameter getParameter(final A key) {
//		if (key == null) {
//			throw new NullPointerException("'key' must not be null");
//		}
//		
//		EnumMap<A, Parameter> pm = getParameterMap();
//		Parameter p = pm.get(key);
//		
//		if (p == null) {
//			Column c = getFactory().getColumn(key);			
//			
//			p = new Parameter(c) {
//				@Override
//				public Object getValue() {					
//					return values().get(key);
//				}
//
//				@Override
//				public void traverse(VisitContext vc, ElementVisitor v) {
//					v.start(vc, this);
//					v.end(this);
//				}
//			};
//		}
//		
//		return p;
//	}
//	
//	
//	
//	private EnumMap<A, Parameter> getParameterMap() {
//		if (parameterMap == null) {
//			parameterMap = new EnumMap<A, Parameter>(getFactory().getColumnNameType());			
//		}
//
//		return parameterMap;
//	}
//		
//	private static Logger logger() {
//		return AbstractEntity.logger;
//	}
//	
//	
//	public void diff(E another) {
//	}				
//		
//	public abstract AbstractEntityMetaData<A, R, Q, ?> getMetaData();
	
}
 